from typing import Dict, Any, Union, List, Callable, Optional
import zmq, traceback, time, logging, xml, socket, abc, dask, threading
from edas.process.task import Job
from edas.process.manager import SubmissionThread
from edas.workflow.data import EDASDataset
from stratus_endpoint.handler.base import Status, Task
from edas.util.logging import EDASLogger
import xarray as xa

class ExecHandler(Task):

    def __init__( self, submissionId: str, _job: Job, **kwargs ):
        super(ExecHandler, self).__init__( **kwargs )
        self.logger = EDASLogger.getLogger()
        self.sthread = None
        self._processResults = True
        self.results: List[EDASDataset] = []
        self.job = _job
        self._status = Status.IDLE
        self.submissionId = submissionId
        self.start_time = time.time()

    def execJob(self, job: Job ) -> SubmissionThread:
        self.sthread = SubmissionThread( job, self.processResult, self.processFailure )
        self.sthread.start()
        self.logger.info( " ----------------->>> Submitted request for job " + job.requestId )
        return self.sthread

    @property
    def status(self):
        return self._status

    def getEDASResult(self, timeout=None, block=False) -> Optional[EDASDataset]:
        self._processResults = False
        if block:
            self.sthread.join(timeout)
            return self.mergeResults()
        else:
            if self._status == Status.COMPLETED:
                return self.mergeResults()
            else: return None

    def getResult(self, timeout=None, block=False) ->  Optional[xa.Dataset]:
        edasResult = self.getEDASResult(timeout,block)
        return edasResult.xr if edasResult is not None else None

    def processResult( self, result: EDASDataset ):
        self.results.append( result )
        self._processFinalResult( )
        if self.portal: self.portal.removeHandler( self.clientId, self.jobId )
        self._status = Status.COMPLETED
        self.logger.info(" ----------------->>> REQUEST COMPLETED "  )

    def _processFinalResult( self ):
        assert len(self.results), "No results generated by request"
        if self._processResults:
            self.logger.info(" ----------------->>> Process Final Result " )
            result = self.mergeResults()
            try:
                savePath = result.save()
                if self.portal:
                    sendData = self.job.runargs.get( "sendData", "true" ).lower().startswith("t")
                    self.portal.sendFile( self.clientId, self.jobId, result.id, savePath, sendData )
                else:
                    self.printResult(savePath)
            except Exception as err:
                self.logger.error( "Error processing final result: " + str(err) )
                self.logger.info(traceback.format_exc())
                if self.portal:
                    self.portal.sendFile(self.clientId, self.jobId, result.id, "", False )

    def mergeResults(self) -> EDASDataset:
        mergeMethod: str = self.results[0]["merge"]
        if mergeMethod is None: return EDASDataset.merge( self.results )
        mergeToks = mergeMethod.split(":")
        return self.getBestResult( mergeToks[0].strip().lower(), mergeToks[1].strip().lower() )

    def getBestResult(self, method: str, parm: str )-> EDASDataset:
        bestResult = None
        bestValue = None
        values = []
        for result in self.results:
            pval = result[parm]
            assert pval, "Error, parameter '{}' not defined in dataset".format( parm )
            values.append(float(pval))
            if bestResult is None or self.compare( method, float(pval), bestValue ):
                bestResult = result
                bestValue = float(pval)
        return bestResult

    def compare(self, method: str, current: float, threshold: float ):
        if method == "min": return current < threshold
        if method == "max": return current > threshold
        raise Exception( "Unknown comparison method: " + method )

    @classmethod
    def getTbStr( cls, ex ) -> str:
        if ex.__traceback__  is None: return ""
        tb = traceback.extract_tb( ex.__traceback__ )
        return " ".join( traceback.format_list( tb ) )

    @classmethod
    def getErrorReport( cls, ex ):
        try:
            errMsg = getattr( ex, 'message', repr(ex) )
            return errMsg + ">~>" +  str( cls.getTbStr(ex) )
        except:
            return repr(ex)

    def processFailure(self, ex: Exception):
        error_message = self.getErrorReport( ex )
        if self.portal:
            self.portal.sendErrorReport( self.clientId, self.jobId, error_message )
            self.portal.removeHandler( self.clientId, self.jobId )
        else:
            self.logger.error( error_message )
        self._status = Status.ERROR
        self._parms["error"] = error_message